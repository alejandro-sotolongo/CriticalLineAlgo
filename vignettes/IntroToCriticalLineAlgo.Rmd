---
title: "Intro to CriticalLineAlgo"
author: "Alejandro Sotolongo"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 6
)
```

```{r}
#devtools::install_github('alejandro-sotolongo/CriticalLineAlgo')
library(CriticalLineAlgo)
```

The critical line algorithm (CLA) was developed by Harry Markowitz to solve the corner portfolios of the efficiency frontier in his famous 1952 *Portfolio Selection* research. An open source version for Python exists and is outlined in the 2013 paper below. `CriticalLineAlgo` is a lightweight R implementation with minimal imports. The only outside package is `MASS` for general (Moore-Penrose) matrix inversion.

This package mostly follows the notation of [Bailey and Lopez de Prado 2013](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2197616) and [Niedermayer and Niedermayer 2006](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=894842).

In this example we'll use expected returns and covariance from [Research Affiliates' Asset Allocation Tool](https://interactive.researchaffiliates.com). I downloaded their valuation-dependent nominal expectations and saved the results in csv files that can be read from Google Drive in the code cell below. The expected returns and covariance matrix were downloaded in November 2019. 

```{r}
mu_vec <- read.csv(sprintf('https://docs.google.com/uc?id=%s&export=download', 
                           '1uC7uADMHxzqB9STQmOIoJ2Bh6O1wqh4O'), 
                   row.names = NULL)
cov_mat <- read.csv(sprintf('https://docs.google.com/uc?id=%s&export=download', 
                           '1E0O583f7F7fX0kZFIgaOtIz8sDFmy3AZ'),
                    row.names = NULL)
asset_class <- mu_vec[, 2]
mu_vec <- mu_vec[, 3]
cov_mat <- as.matrix(cov_mat[, 2:ncol(cov_mat)])
```

`cla_run` is the interface that runs the algorithm and returns the results. The `mu_vec` and `cov_mat` are passed in as the first two arguments.

```{r}
store <- run_cla(mu_vec, cov_mat)
```

The `$wgt_list` in the `store` output contains the weights of the corner portfolios. These weights can easily be combined and used to calculate the corner portfolios' expected return and volatility.

```{r}
corner_wgt <- do.call(cbind, store$wgt_list)
exp_ret <- apply(corner_wgt, 2, function(m, w) {t(w) %*% m}, m = mu_vec)
exp_vol <- apply(corner_wgt, 2, function(covar, w) {sqrt(t(w) %*% covar %*% w)},
                 covar = cov_mat)
plot(sqrt(diag(cov_mat)), mu_vec, col = 'grey', 
     ylab = 'Expected Return', xlab = 'Expected Volatility')
points(exp_vol, exp_ret, col = 'darkgreen')
title('Efficiency Frontier Example')
mtext('Corner Portfolios in Green, Individual Assets in Grey')
rownames(corner_wgt) <- asset_class
round(corner_wgt * 100, 2)[, 1:7]
```

Lower and upperbound weights can be entered to constrain the solution. This implementation of the CLA is already constrained to be long-only and limits the sum of the weights to one. The default for the upperbound weight of each asset is 1. In the previous optimization EM Cash went to high levels fairly quickly. The code below caps EM Cash to 5%.

```{r}
ub <- rep(1, length(mu_vec))
ub[which(asset_class == 'EM Cash')] <- 0.05
store_bound <- run_cla(mu_vec, cov_mat, 0, ub)
corner_wgt <- do.call(cbind, store_bound$wgt_list)
plot(sqrt(diag(cov_mat)), mu_vec, col = 'grey', 
     ylab = 'Expected Return', xlab = 'Expected Volatility')
points(exp_vol, exp_ret, col = 'darkgreen')
title('Efficiency Frontier Example with Constraints')
mtext('Corner Portfolios in Green, Individual Assets in Grey')
rownames(corner_wgt) <- asset_class
round(corner_wgt * 100, 2)[, 1:7]
```
